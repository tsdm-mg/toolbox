use crate::cmd::SignatureArgs;
use crate::utils::load_thread_data_from_dir;
use anyhow::{Context, Result};
use regex::Regex;
use std::fs::OpenOptions;
use std::io::Write;
use std::path::PathBuf;
use tm_api::profile::Profile;
use tokio::fs;

pub async fn run_signature_command(args: SignatureArgs) -> Result<()> {
    let tid = args.tid;
    let profiles = load_profile_data_from_dir(args.profile_data.as_str())
        .await
        .with_context(|| format!("when loading profile from {}", args.profile_data))?;
    println!("loaded {} profiles", profiles.len());

    let mut users_have_content = Vec::<Profile>::new();
    let _ = Regex::new(
        r#"href="https://(www\.)?tsdm39\.(com|net)/forum\.php\?mod=viewthread&amp;tid=tid"#,
    );

    let target = Regex::new(
        format!(
            r#"href="https://(www\.)?tsdm39\.(com|net)/forum\.php\?mod=viewthread&amp;tid={tid}"#
        )
        .as_str(),
    )
    .expect("invalid target url regex");

    for profile in profiles {
        let signature = match profile.signature {
            Some(ref v) => v,
            None => continue,
        };

        if target.is_match(signature.as_str()) {
            users_have_content.push(profile.clone());
            continue;
        }
    }

    println!("{} users linked to content:", users_have_content.len());

    match args.thread_data {
        Some(path) => {
            let (mut output_target, mut tmp_floors) = if let Some(output_path) = args.output {
                (Some(OpenOptions::new().write(true).create(true).truncate(true).open(&output_path).context("failed to open file to save signature check result")?), Vec::<String>::new())
            } else {
                (None, Vec::<String>::new())
            };
            let thread_data = load_thread_data_from_dir(path.as_str())
                .await
                .context("failed to load optional thread data")?;
            let mut sorts = thread_data
                .into_iter()
                .map(|x| {
                    x.thread
                        .post_list
                        .into_iter()
                        .map(|y| (y.author_id, y.floor))
                })
                .flatten()
                .collect::<Vec<_>>();
            sorts.sort_by(|(_, f1), (_, f2)| f1.cmp(f2));

            sorts.iter().for_each(|(uid, floor)| {
                if let Some(u) = users_have_content.iter().find(|y| y.uid == *uid) {
                    println!("{}({} #{})", u.username, u.uid, floor);
                    if output_target.is_some() {
                        tmp_floors.push(format!("{floor}"))
                    }
                }
            });

            // If we have an output_target to save the verified signature floors, do it.
            if let Some(file) = output_target.as_mut() {
                file.write_all(tmp_floors.join("\n").as_bytes()).context("failed to save signature output result")?;
                ()
            }
        }
        None => {
            users_have_content
                .into_iter()
                .for_each(|x| println!("{}({})", x.username, x.uid));
        }
    }

    Ok(())
}

async fn load_profile_data_from_dir(path: &str) -> Result<Vec<Profile>> {
    let mut dir = fs::read_dir(path)
        .await
        .with_context(|| format!("failed to read dir {path}"))?;

    let mut data = vec![];

    let mut root_path = PathBuf::from(path);

    // Files generated by profile subcommand have "${THREAD_ID}_${PAGE_NUMBER}_${FLOOR}.json" format
    // names.
    let file_name_re = Regex::new(r#"post_(?<tid>\d+)_(?<page>\d+)_(?<floor>\d+).json"#)
        .expect("invalid file name regex to validate data file names");
    while let Some(entry) = dir.next_entry().await.context("failed to get next entry")? {
        let file_name = entry.file_name().to_string_lossy().to_string();
        if let None = file_name_re.captures(file_name.as_str()) {
            continue;
        }

        root_path.push(file_name);
        let content = fs::read(&root_path).await?;
        let profile: Profile =
            serde_json::from_slice(content.as_slice()).context("invalid profile json data")?;
        data.push(profile);
        root_path.pop();
    }

    Ok(data)
}
